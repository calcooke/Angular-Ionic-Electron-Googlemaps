{"version":3,"sources":["./src/app/home/home.page.html","./node_modules/uuid/lib/bytesToUuid.js","./node_modules/uuid/lib/rng-browser.js","./node_modules/uuid/v1.js","./src/app/dispatcher.service.ts","./src/app/home/home-routing.module.ts","./src/app/home/home.module.ts","./src/app/home/home.page.scss","./src/app/home/home.page.ts","./src/app/maps.service.ts","./src/app/storage.service.ts"],"names":[],"mappings":"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","file":"home-home-module.js","sourcesContent":["export default \"<ion-split-pane contentId=\\\"map-content\\\">\\n\\n\\n  <ion-menu contentId=\\\"map-content\\\">\\n    <ion-header>\\n      <ion-toolbar>\\n        <ion-title>\\n          <!-- Saved Addresses -->\\n          THIS IS AN UPDATE\\n        </ion-title>\\n      </ion-toolbar>\\n    </ion-header>\\n    <ion-content>\\n      \\n      <!-- Section to display side menu -->\\n\\n      <ion-list>\\n\\n        <ion-item *ngIf=\\\"!addresses.length\\\">\\n          <p>You have no saved addresses. Please select an address from the map.</p>\\n        </ion-item>\\n\\n        <!-- Loop through the addresses array, creating an ion item for each address, with a click handler which\\n        sets the selected address to the address we click on -->\\n\\n        <ion-item *ngFor=\\\"let address of addresses\\\" button (click)=\\\"highlightedAddress=address\\\">\\n\\n          <ion-label>\\n            <p>{{address.addressLine1}}</p>\\n            <p *ngIf=\\\"address.addressLine2\\\">{{address.addressLine1}}</p>\\n            <p>{{address.city}}, {{address.state}}, {{address.zipCode}}</p>\\n          </ion-label>\\n\\n          <!-- Display on whichever address is the current or selected address -->\\n\\n          <ion-icon name=\\\"checkmark\\\" slot=\\\"end\\\" *ngIf=\\\"selectedAddress===address\\\"></ion-icon>\\n\\n          <!-- Clicking this pin icon will make this address the selected address. \\n          Only displayed for the highlighted address. -->\\n\\n          <ion-icon name=\\\"pin\\\" slot=\\\"end\\\" (click)=\\\"provisionAsync(address); highlightedAddress===null\\\" \\n          *ngIf=\\\"highlightedAddress===address\\\"></ion-icon>\\n\\n          <!-- Clicking this displays a confirmation to the user, which if confirmed will be deleted.\\n          Only displayed for the highlighted address. -->\\n\\n          <ion-icon name=\\\"trash\\\" slot=\\\"end\\\" (click)=\\\"onDeleteClick(address)\\\" *ngIf=\\\"highlightedAddress===address\\\"></ion-icon>\\n\\n        </ion-item>\\n      </ion-list>\\n\\n    </ion-content>\\n    <!-- Footer will anchor this to the bottom of the page -->\\n    <ion-footer>\\n      <ion-toolbar>\\n        <ion-title>\\n          Your Information\\n        </ion-title>\\n      </ion-toolbar>\\n      <form [formGroup]=\\\"endpointForm\\\" (ngSubmit)=\\\"saveEndpoint()\\\">\\n        <ion-item>\\n          <ion-label position=\\\"floating\\\">Name</ion-label>\\n          <!-- The hashtag is what binds this to the viewchild decorator -->\\n          <ion-input formControlName=\\\"name\\\" #endpointName></ion-input>\\n        </ion-item>\\n        <ion-item>\\n          <ion-label position=\\\"floating\\\">Phone</ion-label>\\n          <ion-input formControlName=\\\"elin\\\"></ion-input>\\n        </ion-item>\\n        <!-- Disable the button if its not valid or not dirty - which means the user hasn't touched it yet -->\\n        <ion-button type=\\\"submit\\\" [disabled]=\\\"!endpointForm.valid || !endpointForm.dirty\\\" expand=\\\"block\\\"\\n          color=\\\"tertiary\\\">Save</ion-button>\\n      </form>\\n\\n    </ion-footer>\\n\\n  </ion-menu>\\n\\n  <!-- The ion split pane needs two top level elements to control.\\n  In order for the header to appear as a top level header to ionic, but for this to still all be contained\\n  in one section, wrap it in a \\\"section\\\" -->\\n\\n  <section class=\\\"ion-page\\\" id=\\\"map-content\\\">\\n\\n    <ion-header>\\n      <ion-toolbar>\\n        <ion-buttons slot=\\\"start\\\">\\n          <ion-menu-toggle>\\n            <ion-button>\\n              <ion-icon slot=\\\"icon-only\\\" name=\\\"menu\\\"></ion-icon>\\n            </ion-button>\\n          </ion-menu-toggle>\\n        </ion-buttons>\\n        <ion-title>\\n          <!-- Select Location -->\\n          UPDATE HAS REALLY REALLY REALLY  REALLY WORKED\\n        </ion-title>\\n      </ion-toolbar>\\n    </ion-header>\\n\\n    <ion-content>\\n\\n      <agm-map [latitude]=\\\"+selectedAddress.latitude\\\" \\n      [longitude]=\\\"+selectedAddress.longitude\\\"\\n      [zoom]=\\\"18\\\"\\n      [clickableIcons]=\\\"true\\\"\\n      [showDefaultInfoWindow]=\\\"false\\\"\\n      [usePanning]=\\\"true\\\"\\n      (mapClick)=\\\"onMapClick($event)\\\"\\n      >\\n\\n      <!-- Creating markers from our array of addresses -->\\n      <agm-marker *ngFor=\\\"let address of addresses\\\" \\n      [latitude]=\\\"+address.latitude\\\" [longitude]=\\\"+address.longitude\\\"\\n      (markerClick)=\\\"provisionAsync(address)\\\">\\n    \\n        <!-- AGM markers can have info windows when clicked, and need to be set up inside the agm-marker element.\\n        Bind its \\\"is open\\\" property to an expression that evaluates to true wether or not the selected address is \\n        the currentaddress being rendered, with a maximum width of 300px.\\n        We can put any HTML we want inside the window. -->\\n        <agm-info-window [isOpen]=\\\"selectedAddress===address\\\" [maxWidth]=\\\"300\\\">\\n\\n          <ion-label>\\n            <p>{{address.addressLine1}}</p>\\n            <p *ngIf=\\\"address.addressLine2\\\">{{address.addressLine1}}</p>\\n            <p>{{address.city}}, {{address.state}}, {{address.zipCode}}</p>\\n          </ion-label>\\n\\n        </agm-info-window>\\n    \\n      </agm-marker>\\n\\n    \\n      </agm-map>\\n\\n  </ion-content>\\n\\n\\n  </section>\\n\\n</ion-split-pane>\"","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]]\n  ]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n// implementation. Also, find the complete implementation of crypto on IE11.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));\n\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\nvar _clockseq;\n\n// Previous uuid creation time\nvar _lastMSecs = 0;\nvar _lastNSecs = 0;\n\n// See https://github.com/uuidjs/uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [\n        seedBytes[0] | 0x01,\n        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\n      ];\n    }\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  }\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n","import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport {EndPoint} from './end-point';\nimport {environment} from 'src/environments/environment';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DispatcherService {\n\n  //This lets a user set an address as their current address for this theoretical\n  //emergency services app\n\n  constructor(private http: HttpClient) { }\n\n  //Each of these functions take an endpoint and return an endpoint wrapped in a promise\n\n  public async saveEndpointAsync(endpoint: EndPoint){\n\n    //Use a ternary conditional to determine are we saving or updating an existing endpoint\n    //by checking wether or not the endppint has an id. If it has - update, if not - add.\n    //The appropriate function is awaited and it's response assigned to the 'saved' constant.\n    const saved = endpoint.id\n                ? await this.updateAsync(endpoint)\n                : await this.addAsync(endpoint);\n\n    //Once it's saved, pass it to the provisionAsync\n    return this.provisionAsync(saved);\n\n  }\n\n\n  private async addAsync(endpoint: EndPoint){\n\n    //Get the dispatchers base url from the environment to construct the route\n    const url = `${environment.dispatcherUrl}/endpoints`;\n\n    //Build the request itself using the HTTP client, converting the observable returned\n    // to a promise and awaiting it\n    const ep = await this.http.post<EndPoint>(url, endpoint).toPromise();\n\n    //Assign the id of the endpoint returned to the id of the original paramter. \n    endpoint.id = ep.id;\n\n    return endpoint;\n\n  }\n\n\n  private async updateAsync(endpoint: EndPoint){\n\n    //Get the dispatchers base url from the environment to construct the route\n    const url = `${environment.dispatcherUrl}/endpoints`;\n\n    //Use http.put mtehod for updating\n    const ep = await this.http.put<EndPoint>(url, endpoint).toPromise();\n\n    //Return the endpoint object\n    return endpoint;\n\n  };\n\n\n  private async provisionAsync(endpoint: EndPoint){\n\n    //Get the dispatchers base url from the environment to construct the route\n    const url = `${environment.dispatcherUrl}/endpoints/${endpoint.id}`;\n\n    const ep = await this.http.put<EndPoint>(url, endpoint).toPromise();\n\n    //The address status off the address object in the endpoint will have a new status value\n    //so copy it into the endppoint provided, updating it.\n    endpoint.address.addressStatus = ep.address.addressStatus;\n\n    return endpoint;\n\n  };\n\n}\n","import { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { HomePage } from './home.page';\n\nconst routes: Routes = [\n  {\n    path: '',\n    component: HomePage,\n  }\n];\n\n@NgModule({\n  imports: [RouterModule.forChild(routes)],\n  exports: [RouterModule]\n})\nexport class HomePageRoutingModule {}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { IonicModule } from '@ionic/angular';\nimport { FormsModule } from '@angular/forms';\nimport { HomePage } from './home.page';\nimport {ReactiveFormsModule} from '@angular/forms';\n\nimport { HomePageRoutingModule } from './home-routing.module';\nimport { AgmCoreModule } from '@agm/core';\n\n\n@NgModule({\n  imports: [\n    AgmCoreModule,\n    CommonModule,\n    FormsModule,\n    IonicModule,\n    HomePageRoutingModule,\n    ReactiveFormsModule\n  ],\n  declarations: [HomePage]\n})\nexport class HomePageModule {}\n","export default \"#container {\\n  text-align: center;\\n  position: absolute;\\n  left: 0;\\n  right: 0;\\n  top: 50%;\\n  transform: translateY(-50%);\\n}\\n\\n#container strong {\\n  font-size: 20px;\\n  line-height: 26px;\\n}\\n\\n#container p {\\n  font-size: 16px;\\n  line-height: 22px;\\n  color: #8c8c8c;\\n  margin: 0;\\n}\\n\\n#container a {\\n  text-decoration: none;\\n}\\n\\nagm-map {\\n  height: 100%;\\n}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hcHAvaG9tZS9DOlxcVXNlcnNcXENhbHZpblxcRG9jdW1lbnRzXFxHaXRIdWJcXGVsZWN0cm9uLXBpbnBvaW50XFxlbGVjdHJvbi1nb29nbGVtYXBzL3NyY1xcYXBwXFxob21lXFxob21lLnBhZ2Uuc2NzcyIsInNyYy9hcHAvaG9tZS9ob21lLnBhZ2Uuc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtFQUNFLGtCQUFBO0VBRUEsa0JBQUE7RUFDQSxPQUFBO0VBQ0EsUUFBQTtFQUNBLFFBQUE7RUFDQSwyQkFBQTtBQ0FGOztBREdBO0VBQ0UsZUFBQTtFQUNBLGlCQUFBO0FDQUY7O0FER0E7RUFDRSxlQUFBO0VBQ0EsaUJBQUE7RUFFQSxjQUFBO0VBRUEsU0FBQTtBQ0ZGOztBREtBO0VBQ0UscUJBQUE7QUNGRjs7QURLQTtFQUVFLFlBQUE7QUNIRiIsImZpbGUiOiJzcmMvYXBwL2hvbWUvaG9tZS5wYWdlLnNjc3MiLCJzb3VyY2VzQ29udGVudCI6WyIjY29udGFpbmVyIHtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xuXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgbGVmdDogMDtcbiAgcmlnaHQ6IDA7XG4gIHRvcDogNTAlO1xuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7XG59XG5cbiNjb250YWluZXIgc3Ryb25nIHtcbiAgZm9udC1zaXplOiAyMHB4O1xuICBsaW5lLWhlaWdodDogMjZweDtcbn1cblxuI2NvbnRhaW5lciBwIHtcbiAgZm9udC1zaXplOiAxNnB4O1xuICBsaW5lLWhlaWdodDogMjJweDtcblxuICBjb2xvcjogIzhjOGM4YztcblxuICBtYXJnaW46IDA7XG59XG5cbiNjb250YWluZXIgYSB7XG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbn1cblxuYWdtLW1hcCB7IFxuXG4gIGhlaWdodDogMTAwJTtcblxufSIsIiNjb250YWluZXIge1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgbGVmdDogMDtcbiAgcmlnaHQ6IDA7XG4gIHRvcDogNTAlO1xuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7XG59XG5cbiNjb250YWluZXIgc3Ryb25nIHtcbiAgZm9udC1zaXplOiAyMHB4O1xuICBsaW5lLWhlaWdodDogMjZweDtcbn1cblxuI2NvbnRhaW5lciBwIHtcbiAgZm9udC1zaXplOiAxNnB4O1xuICBsaW5lLWhlaWdodDogMjJweDtcbiAgY29sb3I6ICM4YzhjOGM7XG4gIG1hcmdpbjogMDtcbn1cblxuI2NvbnRhaW5lciBhIHtcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xufVxuXG5hZ20tbWFwIHtcbiAgaGVpZ2h0OiAxMDAlO1xufSJdfQ== */\"","import { Component, OnInit, NgZone, ViewChild } from '@angular/core';\nimport { Address} from '../address';\nimport { MapsService } from '../maps.service';\nimport {MouseEvent} from '@agm/core';\nimport { StorageService } from '../storage.service';\nimport { AlertController, IonInput, ToastController } from '@ionic/angular';\nimport {ElectronService} from 'ngx-electron';\nimport {Validators, FormGroup, FormBuilder} from '@angular/forms';\nimport { EndPoint } from '../end-point';\nimport { ThrowStmt } from '@angular/compiler';\n\n\n@Component({\n  selector: 'app-home',\n  templateUrl: 'home.page.html',\n  styleUrls: ['home.page.scss'],\n})\nexport class HomePage implements OnInit {\n\n  endpoint: EndPoint = {};\n  endpointForm: FormGroup;\n\n  //A variable that represents the HTML textbox for the name field.\n  //By decorating a variable declaration with the viewChild decarator, we tell Angular that this variable\n  //is connected to a HTML element inside the view idenfieid by the word 'endpointName'.\n  @ViewChild('endpointName', {static:false}) nameField: IonInput;\n\n  selectedAddress: Address = {\n\n    addressLine1: '4 Yawkey Way',\n    city: 'Boston',\n    state: 'MA',\n    zipCode: '02215',\n    latitude: '42.3466764',\n    longitude: '-71.0994065'\n  };\n\n  //Create address variable as an array of Address objects, initialize as empty.\n  addresses: Address[] = [];\n\n  highlightedAddress: Address;\n\n  constructor(private maps: MapsService, \n    private storage: StorageService, \n    private alertController: AlertController, \n    private electron: ElectronService,\n    private ngZone: NgZone,\n    private fb: FormBuilder,\n    private toastController: ToastController) {\n\n      this.initEndpointForm();\n\n    }\n\n    initEndpointForm() {\n      const phonePattern = /^1[0-9]{10}$/;\n  \n      this.endpointForm = this.fb.group({\n        name: [this.endpoint.name, Validators.required],\n        elin: [this.endpoint.elin, [Validators.required, Validators.pattern(phonePattern)]]\n      });\n    }\n  \n  async ngOnInit() {\n\n    //On init, await a call to the storage service and assign it's return value to the addresses array\n    this.addresses = await this.storage.getAddresses();\n\n    //Load the endpoint and populate the form when the app starts\n    await this.loadEndpoint();\n    //If there is no endpoint, we won't have a name - and in that case we can remind the user to provide it.\n    if(!this.endpoint.name){\n      this.promptForInfo();\n    }\n\n    if(this.electron.isElectronApp){\n\n      //Listen to data from Electron on the 'setAddress' channel. This triggers when an address is clicked on \n      //from the system tray menu, setting the address to be the selected address - panning the location to it.\n      this.electron.ipcRenderer.on('setAddress', (evt, addressId) =>{\n\n        //Some functions and changes happen outside the knowlegde of Angular, and it doesn't know to update\n        //the view. Calling a function from ngZone.run will let angular know that it needs to run change detection as\n        //part of the operation\n        this.ngZone.run(() => this.setAddressById(addressId));\n\n      })\n\n    }\n\n  }\n\n  //Display a toast notifaction to remind the user to fill in the form\n  async promptForInfo(){\n\n    //Call the toast controllers create method, passing in the options object\n    const toast = await this.toastController.create({\n\n      position: 'bottom', // 'top, 'middle'\n      duration: 5000, //Time in ms\n      buttons:[{text: 'OK', role: 'cancel'}],\n      header: 'Provide Your Info', //Title of the toast\n      message: 'Pinpoint needs your name and phone number to set your current address.'\n\n    });\n\n    //Set the focus of the browser to the name field\n    this.nameField.setFocus();\n\n    await toast.present();\n\n  }\n\n  async setAddressById(addressId: string){\n\n    const address = await this.storage.getAddress(addressId);\n\n    if(address){\n\n      this.provisionAsync(address);\n\n    }\n\n  }\n\n  \n  //This is to set an address as your current address. (This app is a theoretical emergency services app that lets a user\n  // save commonly visited addresses and set one as a current address for emergency services purposes)\n  async provisionAsync(address:Address){\n\n    //First ensure we really do have a valid enpoint by checking both properties\n    if(this.endpoint.elin && this.endpoint.name){\n\n      //If so, call the provison function in the storage serverice, which we\n      //must await as it returns a promise\n      await this.storage.provisionAddressAsync(address);\n\n      //Once we get a response, we can set both the selected and highlighted addresses to the endpoint returned\n      this.selectedAddress = address;\n      this.highlightedAddress = address;\n\n    }else{\n\n      //If we still don't have a valid endpoint, prompt the user to provide those values again.\n      this.promptForInfo();\n\n    }\n\n  }\n\n  //This is called from the (mapClick) property set in in AGM in the HTML file, having the event passed into it\n\n  public async onMapClick(event: MouseEvent){\n\n    //Seeing as MouseEvent is imported from agm/core, the event has placeId and coord objects.\n\n    const place = event.placeId || event.coords\n\n    //Now pass either of these these to the map service geocode function.\n    // This function returns a promise, so we'll await it, and set the result equal\n    //to a local constanst called 'address'\n\n    const address = await this.maps.geocode(place);\n\n    //Save the address using the storage service, which assigns it an addressId\n\n    this.highlightedAddress = await this.storage.saveAddress(address);\n\n    //Now push this address into our array of addresses\n\n    this.addresses.push(this.highlightedAddress);\n\n  }\n\n  async onDeleteClick(address : Address){\n\n    //Create an alert to display when the user clicks the delete button\n\n    const alert = this.alertController.create({\n\n      header: 'Delete address?',\n      message: 're you sure you want to delete this address?',\n      buttons: [{\n        text: 'Cancel',\n        role: 'cancel',\n        cssClass: 'secondary',\n        },{\n        text: 'Delete it',\n        handler: () => this.doDelete(address)\n        }\n      ]\n\n    });\n\n    // await a call to the present function, display it on the screen and wait for a user to take action\n    // It's not really blocking the UI, so we have to await it.\n\n    await (await alert).present();\n\n\n  }\n\n  async doDelete(address: Address){\n\n    //Delete an address using it's address ID - which is assigned to it when saved.\n\n    await this.storage.deleteAddress(address.addressId);\n\n    this.highlightedAddress = null;\n\n    //Use the filter function to remove the address from our array list.\n\n    this.addresses = this.addresses.filter(addr => addr.addressId !== address.addressId);\n\n    //In the likelyhood that some other process is adding and deleting addresses, \n    // you could call the getAddresses() function from the storage service again\n\n    // this.addresses = await this.storage.getAddresses();\n\n  }\n\n  async saveEndpoint(){\n\n    //Pass the form's value and pass it to the storage service\n    await this.storage.setEndpoint(this.endpointForm.value);\n\n    return this.loadEndpoint();\n\n  };\n\n  //Calls getenpoint from storage, sets the local variable, and then rests the form so that Angular\n  //no longer considers it dirty. This is a common pattern whenever a form submitted remains visible on the screen.\n  async loadEndpoint(){\n\n    this.endpoint = await this.storage.getEndpoint();\n\n    this.endpointForm.reset(this.endpoint);\n\n  }\n\n}\n","import { Injectable } from '@angular/core';\n//Import the blank module we made so it knows to look for googlemaps\nimport {} from 'googlemaps';\nimport { resolve } from 'url';\nimport {Address} from './address';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class MapsService {\n\n  private geocoder = new google.maps.Geocoder();\n\n  constructor() { }\n\n  //Call this whenever a user clicks on the map\n  //It can take either a string - which means the user clicked on an item on the map that has a google place ID,\n  // or they clicked on a location that has a raw lat/lang location\n  //This geocode function is asynchronous, and returns a promise containing an address\n\n  public geocode(placeIdOrLoction: string | google.maps.LatLngLiteral): Promise<Address> {\n\n    //Create the promise to return\n\n    return new Promise<Address>((resolve,reject) => {\n\n      //Analyse the type of the paramater, setting the location property or place ID\n      const params: google.maps.GeocoderRequest = typeof placeIdOrLoction === 'string'\n        ? {placeId: placeIdOrLoction}\n        : {location: placeIdOrLoction};\n\n        //Now we pass it to the geocoder's geocode function (part of the maps API),\n        // and returns a place based on the information we provide\n        this.geocoder.geocode(params, (results, status) => {\n\n          //If it's successful, it returns status.ok in the callback,\n          //if there's an error, we grab it and reject the promise\n\n          if(status !== google.maps.GeocoderStatus.OK){\n            return reject(status);\n          }\n\n          //If the call is successful, we'll parse the first result in the array of results\n          //as google maps could return more than one result\n\n          const result = results[0];\n\n          console.debug('Geocoding returned', result);\n\n          //The result is parsed into an address\n          //And passed to the caller when we resolve the promise\n          //The parser function (below)loops through the list of key/value pairs from the result\n          // and constructs an address object from the important /relevant pieces\n\n          const address = this.parseResult(result);\n          resolve(address);\n\n        });\n\n    });\n\n  }\n\n  private parseResult(result: google.maps.GeocoderResult): Address {\n\n    const components = result.address_components;\n\n    //Createa new map where key/values are both strings\n    const parsed = new Map<string, string>();\n\n    //for each compoent of the google result,\n    // add them as a new key/value to the parse map.\n\n    for(const component of components){\n\n      for(const type of component.types){\n\n        parsed.set(type, component.short_name);\n\n      }\n\n    }\n\n    //Construct an address object using the key's of the parse map, and the raw lat/lang data from the result\n\n    const address = {\n\n      addressLine1: parsed.get('street_address') || `${parsed.get('street_number')} ${parsed.get('route')}`,\n      city: parsed.get('locality'),\n      state: parsed.get('administrrative_are_level_1'),\n      zipCode: parsed.get('postal_code'),\n      placeId: result.place_id,\n      latitude: result.geometry.location.lat().toString(),\n      longitude: result.geometry.location.lng().toString()\n\n    };\n\n    return address;\n\n\n  }\n\n\n}\n","import { Injectable } from '@angular/core';\nimport {Storage} from '@ionic/storage'\nimport uuid from 'uuid/v1';\n\nimport { Address } from './address';\nimport { ElectronService } from 'ngx-electron';\nimport { EndPoint } from './end-point';\nimport { DispatcherService } from './dispatcher.service';\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class StorageService {\n\n  constructor(private storage: Storage, private electron: ElectronService, private dispatcher: DispatcherService) { }\n\n  //Takes an address and returns an endpoint wrapped by a promise\n  async provisionAddressAsync(address:Address):Promise<EndPoint>{\n\n    //Make sure we have a valid address id, if we  don't we'll call save address to generate one\n    if(!address.addressId){\n      address = await this.saveAddress(address);\n    };\n\n    //Get the saved endpoint, and assign the address into it\n    const endpoint = await this.getEndpoint();\n    endpoint.address = address;\n\n    //Now pass the entire endpoint object into the dispatcher service\n    return this.dispatcher.saveEndpointAsync(endpoint);\n\n  }\n\n  async saveAddress(address: Address): Promise<Address> {\n\n    //If the addres paramter does not already contain an address ID - meaning its new, assign it one\n\n    if(!address.addressId){\n\n      address.addressId = uuid();\n\n    }\n\n    //Ionic storage serialises our storage ti JSON so we don't have to.\n    //All storage functions return a promise, so await it.\n\n    await this.storage.set(address.addressId, address);\n\n    //Send the address list to the electron process tier. Any the Ionic app requests the address list from storage,\n    //or changes it in any way, eg deleting an item - we want to let the Electron app know about it.\n\n    this.updateAddressMenu();\n    \n    return address;\n\n  }\n\n  //Retrieve all addresses from storage\n  //Async as we're awaiting the forEach loop\n\n  async getAddresses(): Promise<Address[]> {\n\n\n    const addresses = [];\n\n    //Take each address and store them in a local array\n\n    await this.storage.forEach(address => {\n\n      //Because anything can be stored in arrays, only add an item to an array if it has an addressId value\n\n      if(address.addressId){\n\n        addresses.push(address);\n      }\n\n    });\n\n    this.updateAddressMenu(addresses);\n\n    //Return the array of addresses\n\n    return addresses;\n\n  }\n\n  //Return a single address passing the addressId as the database key\n  //This does not meed to be marked async as we're not awaiting anything\n\n  getAddress(addressId: string): Promise<Address>{\n\n    return this.storage.get(addressId);\n\n  }\n\n  async deleteAddress(addressId: string): Promise<any> {\n\n    await this.storage.remove(addressId);\n\n    this.updateAddressMenu();\n\n  }\n\n  //Let the electron process know about any changes to the address list.\n\n  async updateAddressMenu(addressList: Address[] = null){\n\n    //Check with NgxElectron to see if we're running inside Electron before sending a message\n\n    if(this.electron.isElectronApp){\n\n      //Check to see if the caller passed us an address list paramater - if not, we'll get i from storage using\n      // the getAddresses function\n\n      const addresses = addressList || await this.getAddresses();\n\n      //We then use the ipc Renderer object to send the list of addresses to electron, on the 'address' channel.\n\n      this.electron.ipcRenderer.send('addresses', addresses);\n\n    }\n\n  }\n\n  //Save the endpoint to the local storage, using the word 'endpoint' as the storage key\n  setEndpoint(endpoint:EndPoint): Promise<void> {\n\n    return this.storage.set('endpoint', endpoint);\n\n  }\n\n  //Retrieve a value fro the localstore using the endpoint key\n  async getEndpoint(): Promise<EndPoint> {\n    \n    const endpoint = await this.storage.get('endpoint');\n    //Return an empty object if it's null\n    return endpoint || {};\n  }\n\n}\n"],"sourceRoot":"webpack:///"}